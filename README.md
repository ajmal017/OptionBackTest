# Option Back-Test
#### From for/if/else to my first back-test function
  
#### 2020/04/12 21:01(第二次更新)
啊我错了……这可真是一个失败的回测函数……我把问题给复杂化了……  
如果今天开仓，交易了多个不同的合约，我根本就不用管到底是看涨还是看跌呀……  
所以输入值应该是这样的：
- signal(int): 用来判断开平仓和不操作
- price(list): 按顺序存放每一个交易合约的当前价格
- position(list): 按顺序存放今天的合约交易方向（买还是卖）
- volume(list): 按顺序存放每张交易合约的成交手数
  
这样写，根本就不需要去思考开的是空头仓还是多头仓，交易的是看涨看跌还是双边了。  
诶，还是自己太菜了……打算下周结束前写完，顺带把舍友的交易波动率策略给实现了……
  
#### 2020/04/12 08:53(第一次更新)
### 写在前面的话
其实是上学期（大四上）在实习的时候有写过一个卖期权的策略（后来还成了我的毕业论文），那时候就觉得期权回测好难写啊，一堆问题要考虑……然后就东补西凑终于把这个策略给写出来了，按照我发小的话说就是：
<p align="center"><b>“在垃圾堆上扔垃圾……”</b></p>
  
结果这次疫情在家，就觉得必须得把所有的东西都整理一遍（因为我强迫症老是发作，浑身难受……），不能老像个垃圾场……而且这个策略的回测函数完全没有可延展性（就是说只能用在这个策略上，换一个就不行了……）。所以我决定了，要自己写一个回测函数，想想也挺简单的，不就一个for循环嘛，到点了开仓，到期了平仓换月，轻轻松松就能搞定……但是直到我写完我才意识到，这是真的不容易呀……  
  
### 输入与输出
动笔之前，我们最先应该明确的就是，我们需要什么？我们已经知道，我们的回测函数大概是一个for循环，到点了自动开平仓，所以每天都要有一个if语句来判断说今天的程序到底应该执行什么样的操作：
```Python
if 开仓:
    空头 or 多头:
        看涨 or 看跌 or 双边:
            保证金 or 期权费 or 手续费
elif 不操作:
    空头:
        计算收益率
        保证金是否满足
    多头:
        计算收益率
    是否加减仓:
elif 平仓:
    计算收益率
    手续费
```
所以我们知道，我们要有：1. 判断开平仓；2. 判断多空头；3. 判断看涨看跌；共3个信号变量，还要有看涨看跌期权每日的保证金，共5个变量。如果考虑加减仓的话，又要多一个信号变量。除此之外，你可能还想设置每次开仓、加减仓的仓位大小，又要再多两个变量……（算了我还是直接放输入端的DataFrame格式吧）：
```Python
def OptionBT(signalDf,depositDf,Capital=1000000,pct=0.8,Fee=2.5,Rde=0.2,Point=10000):
    
    # input:
    # signalDf[DataFrame]: [trade_date, Call_close, Put_close, Call_volume, Put_volume, signal, direction, position, pct]
    # -- signal[int]: -2: 空头平仓, -1: 多头平仓, 0: 不操作, 1: 多头开仓, 2: 空头开仓
    # -- direction[int]: 0: Put, 1: Call, 2: 双边
    # -- position[int]: -1: 减仓, 0: 不操作, 1: 加仓
    # -- pct[float]: 加仓或减仓的比例，仓位变更数量为pct*volume
    # depositDf[DataFrame]: [trade_date, Call_dep, Put_dep]
    # Capital[float]: 本金（元）
    # pct[float]: 开仓百分比
    # Fee[float]: 手续费（元/手）
    # Rde[float]: 保证金上浮比率
    # Point[int]: 期权价格点位比例（元/点）
    
    # output:
    # recordDf[DataFrame]: [trade_date, profit, deposit, signal, position, direction, log, volume, turnover, fee, opfee, capital, strategy]
```
总共13个需要输出的变量，所以我们就需要在for循环的底端，每次都对这13个list append当天的值，而每天的值，都会因今天的开平仓状态不同而有所变化。如，今天是平仓，记得将所有的变量都恢复为初始值，否则下一天不操作的话，数据会继承前一天的值，未清零的值会让本不该进行任何操作的今天进行错误的操作（好吧我知道说得有点绕，下面讲计算每日收益的时候会解释为什么必须这么做……）。  
  
### 每日收益的计算
说实话我一开始也很懵期权每日收益的计算（一张几毛钱为啥会有那么大的收益波动？哦原来我忘记乘点数一万了……）。简单来讲就是：
<p align="center"><b>(Call<sub>t</sub> – Call<sub>t-1</sub>)×Volume×Point</b></p>
  
是的就是这么简单，但是你需要思考一个问题：连续两天的收益=第一天收益+第二天的收益？  
答案是否定的，什么时候才成立呢？当你每天都开盘开仓、收盘平仓时，连续两天的收益才会等于两天各自的收益相加。而你交易期权或者是股票，是买入并持有，即便在你平仓以前它可能会跌到你连裤衩都不剩，但只要你打死都不卖掉，它就不会成为你的损失……  
但这部分损失不能就这么算了呀，会出现这种情况还是你的决策失误，我们算策略的累计收益曲线就是要假设每一天都平仓了，算要是我今天就把期权或者是股票给卖了了，我能赚多少钱？  
所以你还需要一个额外的list来记录你开仓时的期权价格Call<sub>0</sub>，而正确的每日收益计算公式应该是：
<p align="center"><b>(Call<sub>t</sub> – Call<sub>0</sub>)×Volume×Point</b></p>
  
来填补上一节最后留下来的坑了，为什么平仓的时候要把所有变量都恢复初始值：  
看上面的每日收益计算公式，今天的收益要怎么算，取决于你之前开的仓位是多头还是空头，是交易看涨期权、看跌期权还是双边交易。所以相当于是，不操作的每一天，你都要继承前一天的数据，即list.append(list[-1])，这样才能继承到你上一次开仓时的信息，才能知道你开的是啥子仓？今天的收益该怎么算？  
如果你平仓后没有恢复初始值的话，第二天又恰好是不操作，它将继承你上一次开仓的信息，也就是你昨天已经平掉了的仓位信息，继续计算收益！而其实今天的收益应该是0，因为你平仓后又还没有开仓，所以需要对所有的变量进行初始值的恢复，相当于是洗掉上一次开仓时的数据，告诉未来：“我已经准备好了，可以给我新的仓位数据了。在那之前，我将保持没有仓位信息的初始值状态！”  
  
### 其他需要注意的点
1.	保证金的计算：每天都要注意自己的保证金账户是否足够cover你的空头仓位？如果不够，你是准备多交保证金呢？还是直接采取强制平仓措施？这些都由你的回测函数来决定。（期权保证金的计算公式：[干货来啦！期权保证金说明白](https://www.jisilu.cn/question/308680)，当然你还可以自己设定交易所的保证金上浮比率）。
2.	手续费的计算：权利仓的手续费是双边收取的，义务仓的手续费只在平仓时收取，当然不只是平仓，由于保证金不足时导致的强制平仓和减仓操作，都要记得计算手续费（手续费的多少可以由自己设定）。
3.	怎样实现加减仓：这个我不想讲，因为我为了实现这个功能，耗费的时间几乎等于我写完整个不带加减仓功能的回测函数的时间。希望大家好好去思考这个问题，因为思考完它基本上就是把整个函数实现的逻辑都考虑了一遍，对大家理解这个回测的过程还是很有帮助的，所以我决定不讲。它需要考虑的点真的很多，比如说：怎么实现多个仓位不同开仓价格和开仓数量，这是在计算每日收益时必须用到的两个变量，所以你必须想办法用一个list来记录他俩……还有，保证金不够的时候，该平哪个仓？一个仓不够平该怎么平下一个仓？
4.	每次开仓时，若未给定开仓数量，要怎么计算最大的可开仓数：int(capital/deposit)，用你的本金除以保证金或期权费再取整即可（才怪嘞……您又忘了手续费的事情，我们必须保证你的仓位，开得起来，也平得下去，所以还要再多加一步，自己想要怎么写……）。
  
### 策略测试
我们就拿一个简单的策略来测试一下这个回测函数的效果吧~
- 回测周期：2015/04/22~2020/04/10（emmm有点长，不过没关系，只是测试而已……）
- 本金：100w
- 开仓比例：80%（就是每次拿80%的本金来开仓，不一定是80w，你会赚钱的嘛……）
- 手续费：2.5元/张
- 保证金上浮：20%（即每次按规定算完保证金价格后还要再乘以1.2）
- 交易合约：50ETF期权
- 交易规则：（看好了啊！）
>1. 距离期权到期日还有5个交易日的时候，平仓，第二天换下个月到期的合约开仓
>2. 开仓日，50ETF昨日收盘价在其40日均线上方3%，信号为1，下方3%，信号为-1，上下3%之间，信号为0；1则卖开认沽期权，-1卖开认购期权，0则双边卖开（即构建跨式价差期权空头策略）
>3. 开仓后的第5天，开始计算过去5天的信号，若过去5天内，信号有超半数不同，平仓，第二天按新的信号开仓（这里的意思是，过去5天内，50ETF的昨收价已经穿过了均价线，为了及时纠正卖开期权的方向，避免到期时蒙受巨大的损失，我们必须将仓位平掉，换正确的方向重新卖开期权合约）
>4. 开仓后，每天计算交易期权的隐含波动率（这个大家也可以思考下怎么计算比较快，我用的二分法），若昨日的隐含波动率波幅大于5%，则加仓10%，反之小于-5%，减仓10%（其实这个没啥卵用，我只是想测试一下回测函数的加减仓功能是否正常而已……）
  
  
![回测结果](https://github.com/yuba316/OptionBackTest/blob/master/%E5%9B%BE%E7%89%87/%E5%9B%9E%E6%B5%8B%E7%BB%93%E6%9E%9C.png)
  
  
统计量 | 数值
---- | ----
累计收益率% |	143.89175
年化收益率% |	28.93690840220386
年化波动率% |	0.4232228472323804
年化下行波动率% |	0.47926907425729337
夏普比率 |	0.6837274639456167
索提诺比率 |	0.6037716588963388
最大回撤 |	1683591.0
最大回撤百分比 |	1.683591
卡玛比率 |	17.187611719356934
胜率 |	0.71
盈亏比 |	1.2352869181067099
  
### 写在后面的话
好吧一觉醒来，我忽然意识到这个回测函数还是有很多的不足的，比如说，我今天想卖一份认购，买一份认沽外加一份underlying构成衣领策略，上面的回测函数就实现不了了（诶好烦啊我怎么这么菜啊……）。昨天和舍友聊到一个交易波动率的策略，就是一份多头加一份空头的仓位，这让我很头疼，理论上讲，你可能同时买卖多个相同方向但虚实值档位不同的期权……这就需要你有更多的数据结构空间来存储你的多个仓位。我打算下星期把函数给完善了，顺带把这个策略给写完吧（希望可以实现……）。  
P.S.：这个策略为什么中间会有那么大的一段回撤？你看在2018年1月的时候，策略开了认沽仓，不巧，50ETF大跌，平仓在2月份，所以咯……还有2020年年初的事情就不用我说了吧……其实我倒是非常惊讶于2018年以前的策略表现，毕竟这个策略逻辑还挺简单的，居然会有比较稳定的收益哇~？  
策略参考自：
- [申万宏源-期权策略系列报告之二：基于均线系统的卖期权策略研究-170213](http://www.51pdf.cn/Report/View_3090571.html)  
- [研究报告：华泰期货-专题报告：期权隐含波动率异向性策略-180328](http://www.hibor.com.cn/docdetail_2313003.html)
